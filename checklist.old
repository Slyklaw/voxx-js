# Project Overview

Create a 3D voxel terrain engine using `three.js`. The world will be composed of 1-meter cubes and generated using a noise function. The engine should support "infinite" terrain through dynamic loading and unloading of chunks (32x32x32 voxels).

**Core Features:**
- **Rendering:** Use `three.js`.
- **World:** Chunk-based, procedurally generated using noise.
- **Controls:** First-person camera with WASD for horizontal movement, Space/Shift for vertical movement, and mouse for looking. Camera tilt (roll) should be disabled.
- **Performance:** Include an FPS counter and design for performance from the start.

# Voxel Terrain Engine Implementation Checklist

This checklist is structured into milestones to provide a clear development path from a basic prototype to a feature-rich engine.

## Milestone 1: The Basics (MVP)
- [x] **Project Setup:**
    - [x] Initialize project with a build tool (e.g., Vite).
    - [x] Install `three.js` and a noise library (e.g., `simplex-noise`).
- [x] **Scene Setup:**
    - [x] Create a basic `three.js` scene: `Scene`, `PerspectiveCamera`, `WebGLRenderer`.
    - [x] Add basic lighting (e.g., `AmbientLight`, `DirectionalLight`).
    - [x] Add an FPS counter (e.g., `stats.js`).
- [x] **Player Controls:**
    - [x] Implement first-person controls (`PointerLockControls`).
    - [x] Map WASD for horizontal movement.
    - [x] Map Space/Left Shift for vertical movement.
- [x] **Initial World Generation:**
    - [x] Implement a `Chunk` class (e.g., 32x32x32).
    - [x] Use a simple noise function to define a height map.
    - [x] Generate and display a single chunk of terrain using simple `BoxGeometry` for each voxel.

## Milestone 2: Core Engine Features
- [ ] **Infinite World:**
    - [x] Create a `World` class to manage chunks.
    - [x] Dynamically load/unload chunks based on camera position.
    - [ ] Implement a chunk pooling system to reuse chunk objects.
- [x] **Performance Optimization: Meshing**
    - [x] Implement "Greedy Meshing" or "Culled Meshing" to combine adjacent voxel faces into a single geometry. This is a crucial step to move beyond rendering individual cubes.
    - [x] Perform chunk meshing in a Web Worker to avoid blocking the main thread.
- [ ] **Improved Terrain Generation:**
    - [ ] Use fractal noise (multiple octaves) for more interesting terrain.
    - [ ] Make world generation seed-based.
- [ ] **Materials and Textures:**
    - [ ] Create a texture atlas for different block types (e.g., grass, dirt, stone).
    - [ ] Apply textures to voxels based on rules (e.g., height, biome).

## Milestone 3: Advanced Features & Polish
- [ ] **Advanced World Generation:**
    - [ ] Implement a simple biome system (e.g., based on temperature/humidity noise maps).
    - [ ] Add 3D noise for cave generation.
    - [ ] Add water at a fixed level.
- [ ] **Rendering Enhancements:**
    - [ ] Add shadows (`DirectionalLight.castShadow`).
    - [ ] Implement scene fog (`Scene.fog`) for atmospheric effect.
    - [ ] Create a simple day/night cycle by rotating the directional light.
    - [ ] Implement water rendering with transparency and shaders.
- [ ] **Interaction:**
    - [ ] Implement voxel editing (adding/removing blocks) via raycasting.
    - [ ] Add basic AABB (Axis-Aligned Bounding Box) collision detection with the terrain.
- [ ] **UI:**
    - [ ] Add a debug UI (e.g., `lil-gui`) to tweak parameters like noise settings, render distance, etc.

## Milestone 4: Future Goals
- [ ] **Performance:**
    - [ ] Implement a Level of Detail (LOD) system for distant chunks.
    - [ ] Optimize chunk generation and meshing further.
- [ ] **Gameplay & World:**
    - [ ] Integrate a physics engine (e.g., `cannon-es`, `rapier.js`) for more robust collisions and entities.
    - [ ] Implement world saving and loading to `IndexedDB`.

## Quality Assurance
- [ ] Performance testing with large worlds
- [ ] Visual inspection of terrain features
- [ ] Memory usage profiling
- [ ] Cross-browser compatibility testing


Milestone 3, Interaction
 - [x] Implement voxel editing (adding/removing blocks) via raycasting.
    - [x] When the camera is looking at block within range (~10 meters), draw an outline of the selected block
    - [x] Left mouse click destroys the selected block
    - [x] Right mouse click places a new block on the face that the camera is looking directly at
    - [x] Add a '+' reticule where the camera is looking

Milestone, performance
 - [x] Reduce world height 32 blocks
 - [x] Adjust terrain noise to fit lower world height
 - [x] Lower sea level to 10
 - [x] Increase noise frequency by 2x
 
 ## Milestone: Tall world
- [x] Expand the world from 1-layer chunks, to 8-layers
- [x] Adjust the terrain noise parameters to fit the new world height
- [x] Reduce view distance

## Milestone: Block selection UI
- [x] Display the set of blocks along the bottom of the screen UI
- [x] Use mouse wheel to select the current block type
- [x] Highlight the selected block type in the UI
- [x] Adjust block placement code to use the currently selected block type

