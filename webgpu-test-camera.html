<!DOCTYPE html>
<html>
<head>
    <title>WebGPU Camera Test</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="status" style="position: absolute; top: 10px; left: 10px; color: white;">Testing camera matrices...</div>
    
    <script type="module">
        import { WebGPURenderer } from './webgpu/webgpu-renderer.js';
        import { WebGPUCamera } from './webgpu/webgpu-camera.js';
        
        async function testCamera() {
            const canvas = document.getElementById('canvas');
            const status = document.getElementById('status');
            
            try {
                // Initialize renderer
                const renderer = new WebGPURenderer();
                await renderer.init(canvas);
                
                // Create camera positioned to look at origin
                const camera = new WebGPUCamera(75, canvas.width / canvas.height, 0.1, 1000);
                camera.position = { x: 0, y: 0, z: 5 }; // 5 units back from origin
                camera.rotation = { x: 0, y: 0, z: 0 }; // Look straight ahead
                
                // Create a simple triangle at origin
                const vertices = new Float32Array([
                    // Position (x,y,z), Normal (x,y,z), Color (r,g,b)
                     0.0,  1.0, 0.0,  0, 0, 1,  1, 0, 0,  // top (red)
                    -1.0, -1.0, 0.0,  0, 0, 1,  0, 1, 0,  // bottom-left (green)
                     1.0, -1.0, 0.0,  0, 0, 1,  0, 0, 1,  // bottom-right (blue)
                ]);
                
                // Create vertex buffer
                const vertexBuffer = renderer.device.createBuffer({
                    size: vertices.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
                });
                renderer.device.queue.writeBuffer(vertexBuffer, 0, vertices);
                
                // Create fake chunk object
                const testChunk = {
                    vertexBuffer: vertexBuffer,
                    indexBuffer: null,
                    indexCount: 0
                };
                
                // Render once
                function render() {
                    // Update camera
                    camera.updateViewProjectionMatrix();
                    
                    // Identity model matrix
                    const modelMatrix = new Float32Array([
                        1, 0, 0, 0,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                    ]);
                    
                    const lightDirection = [0.5, -1.0, 0.5];
                    const lightColor = [1.0, 1.0, 1.0];
                    const ambientColor = [0.3, 0.3, 0.3];
                    
                    renderer.updateUniforms(
                        camera.viewProjectionMatrix,
                        modelMatrix,
                        lightDirection,
                        lightColor,
                        ambientColor
                    );
                    
                    // Manual render to use draw instead of drawIndexed
                    const commandEncoder = renderer.device.createCommandEncoder();
                    const renderPass = commandEncoder.beginRenderPass({
                        colorAttachments: [{
                            view: renderer.context.getCurrentTexture().createView(),
                            clearValue: { r: 0.0, g: 0.0, b: 0.5, a: 1.0 },
                            loadOp: 'clear',
                            storeOp: 'store'
                        }]
                    });

                    renderPass.setPipeline(renderer.renderPipeline);
                    
                    // Create bind group for uniforms
                    const bindGroup = renderer.device.createBindGroup({
                        layout: renderer.renderPipeline.getBindGroupLayout(0),
                        entries: [{
                            binding: 0,
                            resource: {
                                buffer: renderer.uniformBuffer
                            }
                        }]
                    });
                    
                    renderPass.setBindGroup(0, bindGroup);
                    renderPass.setVertexBuffer(0, vertexBuffer);
                    renderPass.draw(3); // Draw 3 vertices (1 triangle)
                    renderPass.end();
                    
                    renderer.device.queue.submit([commandEncoder.finish()]);
                    
                    // Log camera info once
                    console.log(`Camera pos: ${camera.position.x}, ${camera.position.y}, ${camera.position.z}`);
                    console.log('VP Matrix:', Array.from(camera.viewProjectionMatrix.slice(0, 4)));
                    
                    requestAnimationFrame(render);
                }
                
                render();
                status.textContent = '✅ Camera test running! Should see a triangle with camera transform.';
                
            } catch (error) {
                status.textContent = `❌ Error: ${error.message}`;
                console.error(error);
            }
        }
        
        testCamera();
    </script>
</body>
</html>