<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Voxel Engine</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Time of Day: <span id="timeOfDay">Day</span></div>
        <div>Player Position: <span id="playerPosition">(0, 0, 5)</span></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Basic setup for Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a grid of blocks
        const blockSize = 1;
        const gridSize = 10;
        const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const blockMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });

        for (let x = -gridSize; x < gridSize; x++) {
            for (let y = -gridSize; y < gridSize; y++) {
                for (let z = -gridSize; z < gridSize; z++) {
                    // Generate random color for each block
                    const randomColor = Math.random() * 0xffffff;
                    const blockMaterial = new THREE.MeshStandardMaterial({ color: randomColor });
                    const block = new THREE.Mesh(blockGeometry, blockMaterial);
                    block.position.set(x, y, z);
                    scene.add(block);
                }
            }
        }

        // Player controls
        const player = {
            position: new THREE.Vector3(0, 0, 20),
            rotation: new THREE.Vector2(0, 0),
            speed: 0.1,
            sensitivity: 0.01
        };

        // Outline for selected block
        const outlineGeometry = new THREE.BoxGeometry(1.02, 1.02, 1.02);
        const outlineMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.BackSide, transparent: true });
        const blockOutline = new THREE.Mesh(outlineGeometry, outlineMaterial);
        scene.add(blockOutline);
        blockOutline.visible = false;

        camera.position.copy(player.position);
        camera.rotation.order = 'YXZ';

        document.addEventListener('keydown', (event) => {
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

            switch (event.code) {
                case 'KeyW':
                    player.position.add(forward.multiplyScalar(player.speed));
                    break;
                case 'KeyS':
                    player.position.add(forward.multiplyScalar(-player.speed));
                    break;
                case 'KeyA':
                    player.position.add(right.multiplyScalar(-player.speed));
                    break;
                case 'KeyD':
                    player.position.add(right.multiplyScalar(player.speed));
                    break;
            }
            camera.position.copy(player.position);
        });

        // Mouse click events for block interaction
        // Prevent default context menu
        document.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        document.addEventListener('mousedown', (event) => {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (event.button === 0) { // Left click - destroy block
                if (intersects.length > 0) {
                    const block = intersects[0].object;
                    scene.remove(block);
                }
            } else if (event.button === 2) { // Right click - place block
                if (intersects.length > 0) {
                    const block = intersects[0].object;
                    const direction = camera.getWorldDirection(new THREE.Vector3());
                    const newPosition = new THREE.Vector3()
                        .copy(block.position)
                        .add(direction);

                    // Round to nearest grid unit (1 in this case)
                    newPosition.x = Math.round(newPosition.x);
                    newPosition.y = Math.round(newPosition.y);
                    newPosition.z = Math.round(newPosition.z);

                    const newBlock = new THREE.Mesh(blockGeometry, blockMaterial);
                    newBlock.position.copy(newPosition);
                    scene.add(newBlock);
                }
            }
        });

        document.addEventListener('mousemove', (event) => {
            player.rotation.y -= event.movementX * player.sensitivity;
            player.rotation.x -= event.movementY * player.sensitivity;
            player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
            camera.rotation.set(player.rotation.x, player.rotation.y, 0);

            // Show/hide outline based on block selection
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const block = intersects[0].object;
                blockOutline.position.copy(block.position);
                blockOutline.visible = true;
            } else {
                blockOutline.visible = false;
            }
        });

        // Day/night cycle
        const ambientLight = new THREE.AmbientLight(0x87CEEB, 1); // Sky blue color
        scene.add(ambientLight);

        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(0, 10, 0);
        scene.add(sun);

        let dayNightCycle = 0;
        function updateDayNightCycle() {
            dayNightCycle += 0.005;
            const intensity = Math.abs(Math.sin(dayNightCycle));
            ambientLight.intensity = intensity;
            sun.intensity = intensity;

            // Update UI
            const timeOfDayElement = document.getElementById('timeOfDay');
            if (intensity > 0.5) {
                timeOfDayElement.textContent = 'Day';
            } else {
                timeOfDayElement.textContent = 'Night';
            }

            // Update player position in UI
            const playerPositionElement = document.getElementById('playerPosition');
            playerPositionElement.textContent = `(${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)})`;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateDayNightCycle();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
