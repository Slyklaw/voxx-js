<!DOCTYPE html>
<html>
<head>
    <title>WebGPU Manual Matrix Test</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="status" style="position: absolute; top: 10px; left: 10px; color: white;">Testing with manual matrices...</div>
    
    <script type="module">
        import { WebGPURenderer } from './webgpu/webgpu-renderer.js';
        
        async function testManual() {
            const canvas = document.getElementById('canvas');
            const status = document.getElementById('status');
            
            try {
                // Initialize renderer
                const renderer = new WebGPURenderer();
                await renderer.init(canvas);
                
                // Create a simple triangle
                const vertices = new Float32Array([
                    // Position (x,y,z), Normal (x,y,z), Color (r,g,b)
                     0.0,  1.0, -5.0,  0, 0, 1,  1, 0, 0,  // top (red) - moved back 5 units
                    -1.0, -1.0, -5.0,  0, 0, 1,  0, 1, 0,  // bottom-left (green)
                     1.0, -1.0, -5.0,  0, 0, 1,  0, 0, 1,  // bottom-right (blue)
                ]);
                
                // Create vertex buffer
                const vertexBuffer = renderer.device.createBuffer({
                    size: vertices.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
                });
                renderer.device.queue.writeBuffer(vertexBuffer, 0, vertices);
                
                // Manual perspective projection matrix
                const fov = 75 * Math.PI / 180;
                const aspect = canvas.width / canvas.height;
                const near = 0.1;
                const far = 1000;
                const f = 1.0 / Math.tan(fov / 2);
                
                const projectionMatrix = new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, -(far + near) / (far - near), -1,
                    0, 0, -2 * far * near / (far - near), 0
                ]);
                
                // Identity model matrix
                const modelMatrix = new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
                
                const lightDirection = [0.5, -1.0, 0.5];
                const lightColor = [1.0, 1.0, 1.0];
                const ambientColor = [0.3, 0.3, 0.3];
                
                renderer.updateUniforms(
                    projectionMatrix,  // Use projection as view-projection (no view transform)
                    modelMatrix,
                    lightDirection,
                    lightColor,
                    ambientColor
                );
                
                // Render
                const commandEncoder = renderer.device.createCommandEncoder();
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: renderer.context.getCurrentTexture().createView(),
                        clearValue: { r: 0.0, g: 0.0, b: 0.5, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store'
                    }]
                });

                renderPass.setPipeline(renderer.renderPipeline);
                
                const bindGroup = renderer.device.createBindGroup({
                    layout: renderer.renderPipeline.getBindGroupLayout(0),
                    entries: [{
                        binding: 0,
                        resource: { buffer: renderer.uniformBuffer }
                    }]
                });
                
                renderPass.setBindGroup(0, bindGroup);
                renderPass.setVertexBuffer(0, vertexBuffer);
                renderPass.draw(3);
                renderPass.end();
                
                renderer.device.queue.submit([commandEncoder.finish()]);
                
                status.textContent = '✅ Manual matrix test! Triangle positioned at z=-5 with perspective projection.';
                
            } catch (error) {
                status.textContent = `❌ Error: ${error.message}`;
                console.error(error);
            }
        }
        
        testManual();
    </script>
</body>
</html>